SQL injection
- video: https://www.youtube.com/watch?v=yusJWttsD5o

- attacker interfering with the query that application send into the DB - i.e. authentication
- inject query, execute update/delete
- most common security risk om last years
- only recently fell to 3rd place in OWASP under:
    Broken ACcess Control
    Cryptographic Failures
    
- example
   - naive try, not validated nor parametrized
   - known admin username:
   - supposed query: 
       select * 
         from users 
        where username = 'entered by attacker'
          and password = '' 
  - attacker type: admin '--  
                   -- represent comment in SQL 
  - executed query"
     select * 
         from users 
        where username = 'admin' --' and password = ''  
  -> bypassed authentication         

  Types
   - in band /classic
      * error based
      * union based
      - send payload - getting response in the same communication channel 
      - i.e. authentication: send payload - getting immediately access
      
   - inferential / blind  
      * boolean based
      * time based
      - does not respond the EXACT response in the same communication channel
      - limited  to true/false answers
      - if answer in some way we assume it is true/false
      
   - out of band
      - no response in the same communication channel
      - send payload and response is send to you via your attacking server which get the response
         
process: 
- try to find parameters which are send into the DB
  - i.e. category in the shop 
- find request send to the backend
  - try to crash the query on the UI
  - hope you will get print of the failed query - rare
     - mostly suppressed on backend and returned general error message
  - guessing query:   
    - union based in band:
       1. same number of columns 
          finding number of columns with: order by 1--
            - you have to try to find out how many columns is present in the table
            - couple of iterations -> http 200 OK
            - start from 1 and go up until error (e.g. http 500)
       2. the same type for columns
          we know number of columns, we do not know types
          guessing by setting both to char and see if we get http 200 OK, or 500 internal server error
          adding behind category: ' UNION select 'a', 'a' -- 
          
          executed query will look like this:
          select * from categoryTable where category = ''
          UNION
          select 'a', 'a' 
          
          if OK we can try to attack user table
          select * from categoryTable where category = ''
          UNION
          select username, password from users 

          -prints usernames & passwords
            - nowadays most apps save hash - still usable for the future hacking - dictionary attack 

- inferential / blind  
   -e.g. exploiting tracking cookie
   - does not provide immediate response - i.e. no print to the UI
   -session cookie - generated by framework - unlikely vulnerable 
   -custom cookie (i.e. tracking cookie), which is expected to interact with backend - likely to get exploited     
   
   - raw query:
      Cookie: Trackingid=WhjIolG; session=someBS
        - focus on tracking cookie
        - add: ' and 1=1 -- 
            - if the backend query is vulnerable to injection, this will provide the same result =  true/false
  
        - we can use subquery to find some true/false info
          i.e. is there user called admin
            ' and 1 = (select 1 from users where username='admin') -- 
        - possible to automate with python script to get password based on guessing letters
        - bruteforcing cookie does not have always rate limit or lockout period protection 
        - protection HTTP only flag for cookie - javascript cannot access ~remotely steal that cookie  (might be hijacked if local PC compromised)
        - cookie represents temporary'password' of the user (not the password itself)
  
- prevention:
  - prepared statement/parametrized queries 
     - separates structure from user input 
     - defining query structure
     - set parameters -> does not manipulate the structure of query
                      -> everything as 'string value'
     NOT:
       "select * from table1 where username = " + request.getParameter("x")"
     USE:
       "select * from table1 where username = ?"
       statement = createStatement()
       statement.addParameter();
       statemenet.execute()  
  - additionlly 
     - enforce least privelage 
         - app has lowest privelage when accessing DB
         - like sysadmin - god possibilities - run code on server
                         - user restricted 
         - CIS benchmark?    
         - security patches!
                     
     - whitelist/validation on data
         - white list of allowed characters 
            - banning ' might cause problems for O'Brien surname
          
            
Another brief intro from zSecurity:            
https://www.youtube.com/watch?v=HbYdWajOCx4 
- try to use true statement which keeps website working 
- true false statement which will break it
- use order+by+1 to find count of the columns
- use union based in band injection
   - instead of hacking and guessing datatypes we can use nulls
     union+select+null,null--
- cheatsheet
   - https://portswigger.net/web-security/sql-injection/cheat-sheet               
   - finding DB version - postgress/oracle/mysql 
   
   - get all tables
      i.e. oracle:union select * from all_tables --
   
   - get column names from desired shown table
      i.e.  oracle:union select * from all_tab_columns where table_name ='users' --
               
Real life recent hack MOVEit by OTW (= LARP hacker)           
https://www.youtube.com/watch?v=R1amgARgFDs 
- fuzzing sending payload to the app to try to break it 
   - once it is broken it is the place to focus on
- https://www.shodan.io/ google for finding which companies use what software           
