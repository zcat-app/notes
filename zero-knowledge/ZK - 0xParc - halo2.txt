Halo2
- plonk based
- plonk - SNARK, enforces local and global constraints in universal SNARK
        - selectors - q - pregenerated by verifier
                      x - polynomials filled by prover
        - argument permutations - allowing global constraints  
                                - lagrange poly ower powers of root of unity
                                - swap input of gateway 2 with output of gateway 1 can be swapped because they should be tha same ( g1 -> -- ->g2 )
           -> groth16 set this constraint via trusted setup - different constraint - needs new trusted setup
           
           
- turbo plonk - custom constrains/gates
              - arbitrary linear combinations 
              - verify add challenges y to keep gates linearly independent
              
- hyper plonk - lookup tables
              - if lookup not allowed in the row - gets default value -> lookup works on every row (with default)
              - can performed permutations on some part of lookup

3 layers
- arithmetization - constrains to polynomials, 'PLONKish' arithmetization, creates low degree polynomial
- commitment - create commitment from polynomials, verify random point on commitment, inner product argument
- accumulation - combine opening proofs - recursion, amortized final check on bunch of single proofs (acumulated )

Artihmetization ~ kinds circoms R1CS
- lookup with instance columns - shared between prover-verifier, eg public inputs
              advice columns - private inputs witnessed by prover
              fixed columns - constatns with pre-processed values at keygen
                            - selectors - special fixed columns
                            - binary fixed columns - 0/1
- permutations ~ local - neighbouring cells
                 global - skips over cells
                        - within advice column or on inputs-output
- regions - abstraction to group, boundaries between gates 
          - preserving relative offsets, all offsets inside is 0
          - not influenced by offsets in another regions
          - optimise global space usage
- layouter - arranges automatically regions
           - we cannot depend on position of regions due to layouter
           - global optimization in halo2
           - single pass - pushes regions to first empty row
           - dual pass - second run again - improvement - reducing number of rows 
- rows - expensive due to run of FFT (less rows, less time to process)
- columns - more columns bigger size of the proof
          - commitment for each column -> more commitments = larger proof
           
Commitment scheme           
- inner product argument - alternatives KZP - evm
                                        FRI - POLNKY2
                                        - custom edits for optimization for their needs
- when finished artithemtization we can commit                                        
- commits to polynomials that encodes main component of the circuit ~ each columns (each column ~ polynomial)   
- construct vanishing argument - constraints all circuit relations to zero
- evaluate polynomials at all necessary points given by verifier
- construct multipoint opening argument to check if all evaluations are consistent with commitments
- now all ready for multipoint opening to check all evaluations are consistent with their commitments
  -> querying different gates with different sets of points
    - group commitments by set of points in which they are queried
      - point can be at single row (point x) or can be across rows (neighbour - point omega x) - linear combination of point
    - construct polynomials to accumulate at each point set - linearly combine each set
    - evaluate qi at their respective points
    - interpolate qi and construct new polynomials f to check their correctness
    - construct f polynomial with random y to keep fi polys linearly independent
    - finally create poly P = f(x) + r * q0(x) + r^2 * q1(x) at random point r to make them linearly independent 
                                                            -> checks evaluations with respective commitments
                                                            -> goals is to get low degree polys for inner product argument
        -> goal is to optimize and reduce the number of polynomials (rows) and commitments and evaluation we need
- run inner product argument (IPA) to create polynomial commitment opening proof for multipoint opening argument  
  - allows to provide opening proof in log n size for actual polynomial
  - redux2 fft like approach - wtf?
     ~ multiple rounds - halving poly in each round
     - similar to Bootle/Bullet proofs 
  - no trusted setup
  
Accumulation scheme
- enables recursion in halo2
- idea is to accumulate cheap validations of 2 or more instances rather than do big one expensive 
- does O(log n) accumulation steps and then later in time passes to the final check to be checked in O(n) time in 'decider'
  - if last instance passes, all previous should be fine too
-> incrementally verifiable computation (ICV)
  - updates accumulator with inputs and checking that update was done correctly ~ the cheap check
  - creates proof from passed business logic and accumulation verification
  - can be passed further to repeat in other blocks -> IVC prover
  - once done enough - accumulator passed to decider ~ IVC verifier - also generates the final SNARK verification
  
  
  
  
PLONKY3  
